### 阻塞锁

lock语句可以很好地处理99%的情况，关于锁的使用，有4条原则：

- 限制锁的作用范围（lock语句的作用对象应为私有）
- 文档中写清锁保护的内容
- 锁范围内的代码尽量少
- 在控制锁的时候绝不运行随意的代码（引发事件、调用虚方法、调用委托）

### 异步锁

```c#
private readonly SemaphoreSlim _mutex = new SemaphoreSlim(1);
private int _value;
public async Task DelayAndIncrementAsync()
{
    await _mutex.WaitAsync();
    try
    {
        var oldValue = _value;
        await Task.Delay(TimeSpan.FromSeconds(oldValue));
        _value = oldValue + 1;
    }
    finally
    {
        _mutex.Release();
    }
}
```

### 阻塞信号

锁是来保护共享数据的，不能作为信号。

ManualResetEvent和AutoResetEvent的

- 相同点：

  均继承 EventWaitHandle 接口，因此，均具有以下功能:

  Reset() //红灯

  Set() //绿灯

  WaitOne() // 等待信号

- 不同点：
  1）AutoResetEvent.WaitOne()每次只允许一个线程进入，当某个线程得到信号后，AutoResetEvent会自动又将信号置为不发送状态，则其他调用WaitOne的线程只有继续等待，也就是说AutoResetEvent一次只唤醒一个线程；
  2）ManualResetEvent则可以唤醒多个线程，因为当某个线程调用了ManualResetEvent.Set()方法后，其他调用WaitOne的线程获得信号得以继续执行，而ManualResetEvent不会自动将信号置为不发送。
  3）也就是说，除非手工调用了ManualResetEvent.Reset()方法，则ManualResetEvent将一直保持有信号状态，ManualResetEvent也就可以同时唤醒多个线程继续执行。

msdn 提到(如果没有线程 处于WaitOne() 状态,而调用 Set ， AutoResetEvent 将保持Set 状态)：调用Set信号AutoResetEvent释放等待线程。 AutoResetEvent 将保持终止状态直到一个等待线程释放，并自动返回到非信号状态。 如果没有线程处于等待状态，状态将无限期地保持已发出信号。

**因此通常WatiOne 之前，先 Reset() 一下，清除Set 信号**

**两个 Set 调用之间时间较短，第二个 Set 信号可能会丢失，因此连续 Set 调用，中间需要 Sleep 一定时间**